---
/**
 * Stars.astro
 * CSS만으로 별이 박힌 밤하늘과 반짝이는 효과를 구현합니다.
 */

// 유성 설정: 개수와 랜덤 데이터 생성 (Astro Sphere 스타일을 위해 개수 최적화)
const METEOR_COUNT = 6;
const meteors = Array.from({ length: METEOR_COUNT }).map(() => ({
  top: (Math.random() * 80 + 10) + "%", // 10% ~ 90% (화면 안쪽 목적지)
  left: (Math.random() * 80 + 10) + "%", // 10% ~ 90% (화면 안쪽 목적지)
  duration: (Math.random() * 2 + 1) + "s", // 1~3초 사이 비행 속도 (더 빠르게)
  delay: (Math.random() * 20 + 2) + "s",  // 2~22초 사이 랜덤 딜레이
}));
---
<div id="star-container" class="stars-container fixed inset-0 -z-10 bg-black overflow-hidden pointer-events-none transform-gpu">
  {/* 배경의 반짝이는 별들 */}
  {Array.from({ length: 120 }).map((_, i) => {
    const size = Math.random() * 1.5 + 0.5;
    const left = Math.random() * 100;
    const top = Math.random() * 100;
    const duration = Math.random() * 3 + 2;
    const delay = Math.random() * 5;
    
    return (
      <div 
        class="star" 
        style={`
          width: ${size}px; 
          height: ${size}px; 
          left: ${left}%; 
          top: ${top}%; 
          --twinkle-duration: ${duration}s;
          animation-delay: ${delay}s;
        `}
      />
    );
  })}
  
  {/* Astro Sphere 스타일의 길고 우아한 유성들 (화면 밖에서 시작해 화면 안에서 소멸) */}
  {meteors.map((m) => (
    <div 
      class="meteor" 
      style={`
        top: ${m.top}; 
        left: ${m.left}; 
        animation-duration: ${m.duration};
        animation-delay: ${m.delay};
      `}
    />
  ))}
</div>

<style>
  /* 성능 최적화를 위한 힌트 제공 */
  .stars-container {
    will-change: transform;
    height: 120vh; /* 패럴랙스 이동을 위한 여유 공간 */
  }
</style>

<script>
  // 클라이언트 사이드에서 패럴랙스 로직 실행
  const container = document.getElementById('star-container');
  
  if (container) {
    let lastScrollY = window.scrollY;
    let ticking = false;
    
    // 패럴랙스 강도 (0.1 ~ 0.2 권장)
    const PARALLAX_SPEED = 0.15; 

    const updateParallax = () => {
      // 스크롤에 따라 배경을 아주 조금씩 이동시킴
      const translateY = -(lastScrollY * PARALLAX_SPEED);
      container.style.transform = `translate3d(0, ${translateY}px, 0)`;
      ticking = false;
    };

    const onScroll = () => {
      lastScrollY = window.scrollY;
      if (!ticking) {
        window.requestAnimationFrame(updateParallax);
        ticking = true;
      }
    };

    // passive 옵션으로 스크롤 성능 확보
    window.addEventListener('scroll', onScroll, { passive: true });
  }
</script>
